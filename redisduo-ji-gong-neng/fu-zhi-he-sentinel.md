# 复制和Sentinel

扩展系统处理读请求的能力 , 并提高系统的可用性 .

### 复制

创建具有相同数据库的拷贝服务器 .

Redis的复制\(replication\)功能允许用户根据一个Redis服务器来创建任意多个该服务器的复制品 , 其中被复制的服务器为主服务器\(master\) , 而通过复制创建出来的服务器复制品则为从服务器\(slave\) . 主从服务器两者拥有相同的数据库数据 , 只要主从服务器之间的网络连接正常 , 主服务器就会一直将发生在自己身上的数据更新同步给从服务器 , 从而一直保证主从服务器的数据相同 .

![](/assets/fuzhi.png)

图中展示了一个拥有一个 从服务器的主服务器 , 和一个拥有三个从服务器的主服务器 ,

#### 使用从服务器来处理读命令请求

Redis允许从服务器执行客户端发送的读命令 , 比如GET、LRANGE、SMEMBERS、HGET、

ZRANGE等等 .

因为主从服务器拥有相同的数据库数据 , 所以从服务器在执行客户端发送的读命令时 , 获得的结果与主服务器执行相同的读命令所获得的结果是一样的 . 因此 , 用户可以将原本由主服务器负责处理的一部分\(甚至全部\)读命令请求转交给从服务器处理 , 从而降低主服务器在处理读命令请求方面的负载 , 并扩展整个系统处理读命令请求的能力 .

![](/assets/fuzhi2.png)

#### 通过复制来扩展系统处理读请求的能力

通过添加从服务器可以线性的扩展整个系统处理读命令请求的能力 .

| 服务器配置 | 每秒钟能够处理的读命令请求数量 |
| :--- | :--- |
| 一台主服务器 | N |
| 一台主服务器+一台从服务器 | 2N |
| 一台主服务器+两台从服务器 | 3N |
| 一台主服务器+三台从服务器 | 4N |
| ...... | ...... |

### 从服务器的创建与使用

使用SLAVEOF命令或者slaveof选项 .

#### 创建从服务器的方法

Redis提供了两种方法来为某个主服务器创建从服务器 :

* **使用**`SLAVEOF <master-ip><master-port>`**命令 . **比如向一个服务器发送SLAVEOF 127.0.0.1 6379 , 可以让接收到该命令的服务器变为127.0.0.1:6379的从服务器 . 在将一个服务器设置成从服务器之后 , 可以通过向它发送SLAVEOF no one来让它变回一个主服务器\(数据库已有的数据会被保留\) . 
* 在启动服务器时 , 通过**设置**`slaveof <master-ip><master-port>`**配置选项**来让服务器成为指定服务器的从服务器 . 

**举例说明**

如果客户端对服务器`127.0.0.1:6380`发送命令`SLAVEOF 127.0.0.1 6379` , 那么`127.0.0.1:6380`将成为`127.0.0.1:6379`的从服务器 .

![](/assets/fuzhi34.png)

**命令操作**

```
127.0.0.1:6379> SET msg "hello world"
OK
127.0.0.1:6379> INCR counter 
(integer) 1
127.0.0.1:6379> INCR counter 
(integer) 2
127.0.0.1:6379> RPUSH lst 1 3 5 7 9 
(integer) 5
127.0.0.1:6380> GET msg "hello world"
127.0.0.1:6380> GET counter 
"2"
127.0.0.1:6380> LRANGE lst 0 -1 
1) "1"
2) "3"
3) "5"
4) "7” 
5) "9"
```

### 处理服务器下线

#### 服务器在复制时遭遇下线

在实际的世界中 , 因为故障而导致服务器下线的情况总是不可避免的 .

在一个由主服务器和从服务器组成的系统中 , 主服务器或者从服务器都有可能会下线 , 但是不同服务器下线带来的影响并不相同 :

* 如果下线的是从服务器 , 那么整个系统处理读请求的性能将有所下降 , 但整个系统仍然可以继续处理写请求和读请求 , 所以这种下线不会导致系统停机 ; 
* 另一方面 , 因为在整个系统里面 , 只有主服务器一个能够处理写请求 , 所以如果下线的是主服务器 , 那么整个系统将只能处理读请求而无法处理写请求 , 导致系统停机 . 

#### 从服务器下线示例

![](/assets/xiaxian1.png)

从服务器B下线 , 导致客户端C的访问失败 , 但只要客户端C改为访问其他在线的服务器 , 就可以解决这个问题 .

#### 主服务器下线示例

![](/assets/xiaxian2.png)

主服务器下线导致主从服务器的连接中断 , 并使得整个系统无法再执行写命令 . 这时从服务器还是可以继续处理读请求的 , 但是从服务器的数据会因为主服务器下线而没办法再得到更新 .

#### 让系统重新上线的方法

为了让系统能够回到正常上线状态\(也即是 , 让系统中的服务器既能够处理读请求 , 又能够处理写请求\) , 用户需要向系统中的某一个从服务器发送SLAVEOF no one命令 , 让它变为新的主服务器 , 并向其他从服务器发送SLAVEOF命令 , 让他们去复制新的从服务器 . 

![](/assets/shangxian11.png)

![](/assets/shangxian1.png)

现在系统有了新的主服务器 , 以及一个从服务器,客户端可以继续使用这个系统来处理读请求和写请求了 . 

因为有一台服务器下线了的缘故 , 所以重新上线的系统在性能方面可能比不上原有的系统 , 但这种恢复操作可以避免整个系统停机 . \(如果不想系统恢复之后的性能被影响 , 可以添加额外的从服务器 , 用作冗余服务器\) . 

![](/assets/shangxian3.png)

虽然上面介绍的方法可以让系统重新上线 , 但手动来执行这些操作实在太麻烦了 , 为此Redis提供了Sentinel程序 , 用户可以使用Sentinel来自动检测主从服务器的状态 , 并在主服务器下线时 , 自动执行故障转移操作\(failover\) , 让系统重新上线 . 

