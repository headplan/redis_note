# Lua脚本

在服务器端执行复杂的操作 .

**附加功能**

* 流水线 - 打包发送多条命令 , 并在一个回复里面接收所有被执行命令的结果
* 事务 - 一次执行多条命令 , 被执行的命令要么全部执行 , 要么都不执行 , 事务执行过程中不会被其他工作打断 . 
* 乐观锁 - 监视特定的键 , 防止事务出现竞争条件 . 

附加功能非常有用 , 但是他们也存在一些缺陷 .

#### 流水线的缺陷

尽管使用流水线可以一次发送多个命令 , 但是对于一个由多个命令组成的复杂操作来说 , 为了执行该操作而不断地重复发送相同的命令 , 这并不是最高效的做法 , 会对网络资源造成浪费 .

如果我们有办法避免重复地发送相同的命令 , 那么客户端就可以减少花在网络传输方面的时间 , 操作就可以执行得更快 .

#### 事务和乐观锁的缺陷

虽然使用事务可以一次执行多个命令 , 并且通过乐观锁可以防止事务产生竞争条件 , 但是在实际中 , 要正确地使用事务和乐观锁并不是一件容易的事情 .

1.对于一个复杂的事务来说 , 通常需要仔细思考才能知道应该对哪些键进行加锁 : 锁了不应该锁的键会增加事务失败的机会 , 甚至可能会造成程序出错 ; 而忘了对应该锁的键进行加锁的话 , 程序又会产生竞争条件 .

2.有时候为了防止竞争条件发生 , 即使操作本身不需要用到事务 , 但是为了让乐观锁生效 , 我们也会使用事务将命令包裹起来 , 这增加了实现的复杂度 , 并且带来额外的性能损耗 .

例如前面事务功能中实现的ZDECRBY命令 , 使用事务仅仅是为了让WATCH生效而已 : 

```py
def ZDECRBY(key, decrment, member):
    # 监视输入的有序集合
    WATCH key
    # 取得元素当前的分 值
    old_score = ZSCORE key member
    # 使用当前分值减去指定的减量,得出新的分值 
    new_score = old_score - decrment
    # 使用事务包裹 ZADD 命令
    # 确保 ZADD 命令只会在有序集合没有被修改的情况下 执行
    MULTI
    ZADD key new_score member 
    # 为元素设置新分值,覆盖现有的分值 
    EXEC
```

最好的方式 , 就是可以以事务的方式执行多个命令 , 还不会引入任何竞争条件 , 来替代事务和乐观锁 . 

