# 列表\(list\)

以有序的方式存储多个可重复的值.

一个列表可以包含一个或以上数量的项\(item\),每个项按照它们被推入到列表的位置来排列.

每个列表项所处的位置决定了这个项的索引值\(index\),索引以0开始,从列表的左端到右端依次递增,位于列表最左端\(表头\)的项的索引为0,而位于列表最右端\(表尾\)的项的索引为N-1,其中N为列表的长度.

列表包含的项可以出现重复,它们不必是唯一的.

![](/Snip20160712_6.png)

### 推入和弹出操作

了解如何向列表添加项,以及如何从列表里面删除项.

#### 从列表的左端推入值

```
LPUSH key value [value ...]
```

* 将一个或以上数量的值依次推入到列表的左端,命令返回新值被推入之后,列表目前包含的项数量

* 复杂度O\(N\),N为被推入值的数量,如果只推入一个值,就是O\(1\)

```
LPUSH lst "lua"
LPUSH lst "Python"
LPUSH lst "C"
```

#### 从列表的左端推入多个值

如果执行 LPUSH 命令时给定了多个值,那么各个值将按照给定时的顺序,从左到右依次地被推入到列表的左端.

```
LPUSH lst "lua" "Python" "C"
```

注:值被推入的顺序和参数给定的顺序正好相反

#### 从列表的右端推入值

```
RPUSH key value [value ...]
```

* 将一个或以上数量的值依次推入到列表的右端,命令返回新值被推入之后,列表目前包含的项数量.

* 复杂度为O\(N\),N为被推入值的数量

```
RPUSH lst "JS"
RPUSH lst "Ruby"
Rpush lst "C"
```

#### 从列表的右端推入多个值

如果执行 RPUSH 命令时给定了多个值,那么各个值将按照给定时的顺序,从左到右依次被推入到列表的右端.

```
RPUSH lst "JS" "Ruby" "C"
```

注:值被推入的顺序和参数给定的顺序正好相反

#### 从列表的两端弹出项

```
LPOP key - 移除并返回列表最左端的项 - 复杂度O(1)
RPOP key - 移除并返回列表最右端的项 - 复杂度O(1)
```

![](/Snip20160712_7.png)

```
RPUSH lst "Clojure" "Ruby" "C" "Python" "Lua"
LPOP lst
"Clojure"
LPOP lst
"Ruby"
RPOP lst
"Lua"
RPOP lst
"Python"
```

---

### 长度,索引和范围操作

#### 获取列表的长度

```
LLEN key
```

* 返回列表键key的长度,就是返回列表包含的列表项数量

* 因为Redis会记录每个列表的长度,所以这个命令无需遍历列表

* 复杂度为O\(1\)

```
LLEN lst
LPOP lst
LLEN lst
```

#### 返回给定索引上的项

```
LINDEX key index
```

* 返回列表键key中,指定索引index上的列表项

* index索引可以是整数或者负数

* 复杂度为O\(N\),N为列表的长度

```
LINDEX lst 1
LINDEX lst 4
LINDEX lst -3
```

#### 返回给定索引范围之内的所有项

```
LRANGE key start stop
```

* 返回列表键key中,从索引start至索引stop范围内的所有列表项.

* 两个索引参数都可以是正数或者负数

* 复杂度为O\(N\),N为被返回的列表项数量

```
LRANGE lst 0 2
LRANGE lst -3 -1
```

---

### 插入和删除操作

#### 设置指定索引上的列表项

```
LSET key index value
```

将列表键key索引index上的列表项设置为value , 设置成功时命令返回OK . 如果index参数超过了列表的索引范围 , 那么命令返回一个错误 .

针对表头和表尾节点进行处理时\(index为0或者-1\) , 命令的复杂度为O\(1\) ; 其他情况下 , 命令的复杂度为O\(N\) , N为列表的长度 .

#### 在指定位置插入列表项

```
LINSERT key BEFORE|AFTER pivot value
```

根据命令调用时传递的是BEFORE选项还是AFTER选项 , 将值value插入到指定列表项pivot的之前或者之后 . 当pivot不存在于列表key时 , 不执行任何操作 .

返回-1表示pivot不存在 ; 返回0表示键key不存在 ; 插入成功时则返回列表当前的长度 .

复杂度为O\(N\) , N为列表长度 .

#### 从列表中删除指定的值

```
LREM key count value
```

根据参数count的值,移除列表中与参数value相等的列表项:

* 如果count &gt; 0 , 那么从表头开始向表尾搜索 , 移除最多count个值为value的列表项 . 
* 如果count &lt; 0 , 那么从表尾开始向表头搜索 , 移除最多abs\(count\)个值为value的列表项 . 
* 如果count = 0 , 那么移除列表中所有值为value的列表项 . 

命令返回被移除列表项的数量 .

命令的复杂度为O\(N\) , N为列表的长度 .

#### 修剪列表

```
LTRIM key start stop
```

对一个列表进行修剪\(trim\) , 让列表只保留指定索引范围内的列表项 , 而将不在范围内的其他列表项全部删除 . 两个索引都可以是正数或者负数 .

命令执行成功时返回OK , 复杂度为O\(N\) , N为被移除列表项的数量 .

---

### 阻塞式弹出操作

| 命令 | 作用 | 复杂度 |
| :--- | :--- | :--- |
| BLPOP key \[key ...\] timeout | LPOP命令的阻塞版本; 命令会以从左到右的顺序,访问给定的各个列表,并弹出首个非空列表最左端的项; 如果所有给定列表都为空,那么客户端将被阻塞,直到等待超时,或者有可弹出的项出现为止;设置timeout参数为0表示永远阻塞。 | O\(N\),N为输入列表的数量。 |
| BRPOP key \[key ...\] timeout | RPOP命令的阻塞版本: 命令会以从左到右的顺序,访问给定的各个列表,并弹出首个非空列表最右端的项; 如果所有给定列表都为空,那么客户端将被阻塞,直到等待超时,或者有可弹出的项出现为止;设置timeout参数为0表示永远阻塞。 | O\(N\),N为输入列表的数量。 |

#### 情形一:非阻塞

![](/assets/list_1.png)

当发现给定的列表中有至少一个非空列表时 , BLPOP或者BRPOP就会立即从那个列表里面弹出元素 , 在这种情况下 , BLPOP就像一个接受多参数的LPOP命令 , 而BRPOP就像一个接受多参数的RPOP命令 . 

#### 情形二:阻塞并超时

如果所有给定列表都是空的 , 那么BLPOP/BRPOP将被阻塞 . 如果在阻塞的过程中 , 给定的列表一直没有新项被推入 , 那么当设定的超时时间到达之后 , 命令将向被阻塞的客户端返回nil .

#### 情形三:阻塞并弹出情况

如果在客户端X被阻塞的过程中 , 有另一个客户端Y给成客户端X被阻塞的列表推入了新项 , 那么服务器会将这个新项返 回给客户端X . 

#### BLPOP/BRPOP的先到先服务原则

如果有多个客户端同时因为某个列表而被阻塞 , 那么当有新值被推入到这个列表时 , 服务器会按照先到先服务\(first in first service\)原则 , 优先向最早被阻塞的客户端返回新值 . 

举个例子 , 假设列表lst为空 , 那么当客户端X执行命令BLPOP lst timeout时 , 客户端X将被阻塞 . 

在此之后 , 客户端Y也执行命令BLPOP lst timeout , 也因此被阻塞 .

如果这时 , 客户端Z执行命令RPUSH lst "hello" , 将值"hello"推入列表lst , 那么这个"hello"将被返回给客户端X , 而不是客户端Y , 因为客户端X的被阻塞时间要早于客户端Y的被阻塞时间 . 



